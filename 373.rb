class String
  def to_tree
    eval(gsub(/[\(\)]/, {?( => ?[, ?) => "],"})[0..-2])
  end
end

class Array
  def recursive_sort
    map { |sub_a| sub_a.recursive_sort }.sort
  end
end

def equal(s1, s2)
  s1.to_tree.recursive_sort == s2.to_tree.recursive_sort
end

# DATA.each_line.map do |line|
#   equal(*line.split(" "))
# end.instance_eval { puts count(true) }

@id = 1.step
Tree = Struct.new(:root, :children) do
  def embeddable_in?(o)
    vs = o.valid_subtrees(children.count).map { |oid| o.find_subtree(oid) }
    children.map { |c| vs.map { |o2| c.embeddable_in?(o2) } }.flatten.all?
  end

  def valid_subtrees(count)
    vs = []
    if children.count >= count
      vs << self.root
    end
    vs << children.map { |c| c.valid_subtrees(count) }.flatten
    vs.flatten
  end

  def find_subtree(id)
    root == id ? self : children.map { |c| c.find_subtree(id) }.flatten.compact.first
  end
end

def build_tree(s)
  a = s.class == String ? s.to_tree : s
  tree = Tree.new(@id.next, [])
  a.each { |sa| tree.children << build_tree(sa) }
  tree
end

DATA.each_line.map do |line|
  t1, t2 = line.split(" ").map(&:to_tree).map { |t| build_tree(t) }
  t1.embeddable_in?(t2)
end.instance_eval { count(true) }

__END__
(((()(())(()))()(()())()())((())(()())(()()())(()()()()()(()()))(())())(()()()())((())()()()()()(()))(((())()((())())(()))(()())(()((())()())())((())())(()()(())(())())(()()())(()))(()(()()()()())(()()()(()())()())()()()(())((())()()(()()())))((()(())(()))()())((()()())((()())(()())(()))(()())()((())()())(()()()((()(()))())(()(())()())(())(((())())()()()))(()())(()()()(((()))())))(()(())(())(()))) ((((())()(())())()((())()()())(())()(()())(())(()(()())()(()()())()())(()(())((())()(()))))((())(()())()()(()(())())()(())(()(())()))(()(()()())(()()(())()())(())()(()()(()())(()()))(()())(()))((())(()(()())())((()())()())(()(())())((())(())()(())())((())(())(()())(()())(()(())(()()())()()())(())(())(()()(()())()(())()))((()()())(()()()())()(())(())())(()()())(()(())()))((()()(())(())()())(()((())(((())))()())(())(()(()())()()()(()))(())(()))(()()())(()(())()()())(()()(()(())()(()()()())()(())())()()(()()(()()()())()(())()()())(()()()())(()())(()()))(()()()()(()(())()))(()()(()(()()))()()()(())((())()()(()))())((())((()))(()())(())())(()()(())))(()(()(()())(()))()()(()()()(())(()()))(()))(((()())(())())(()(())()()((())())())(()(()(()())()(())(()))()(()()()()())(()(())())(())()(()))((()())()()())(()(())(()))((()()())(()())()()(()))((()()()(())(()()())(()))(())()((())()((())(())))(()()()()())()(()()()()(()))((()()()())()()))(()()(()(())(()))()()(()(()))(()()()()))((()(()()()())()()()()(()()))(()())((()))(((()())())()(())()(()())(())())((())()()(())())(())()((())()())(()()()()(()))))((())(())(())()((())()(()))((())(())()())(()()))(()(()())(())()(())((()()())())(()())((())(())()(()))))
